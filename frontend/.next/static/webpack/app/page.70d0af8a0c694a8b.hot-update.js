"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./lib/process-dataset.ts":
/*!********************************!*\
  !*** ./lib/process-dataset.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getFairnessResult: () => (/* binding */ getFairnessResult),\n/* harmony export */   getProcessedDataset: () => (/* binding */ getProcessedDataset),\n/* harmony export */   processDataset: () => (/* binding */ processDataset),\n/* harmony export */   setProcessedDataset: () => (/* binding */ setProcessedDataset),\n/* harmony export */   uploadDatasetToBackend: () => (/* binding */ uploadDatasetToBackend)\n/* harmony export */ });\n/**\n * Real CSV processing implementation\n */ // Function to detect if a column might be a protected attribute\nfunction analyzeColumnForProtectedAttributes(columnName, values) {\n    const name = columnName.toLowerCase();\n    // Known protected attribute patterns\n    const protectedPatterns = [\n        {\n            pattern: /gender|sex/,\n            confidence: 0.95,\n            risk: \"high\"\n        },\n        {\n            pattern: /age|birth|dob/,\n            confidence: 0.92,\n            risk: \"high\"\n        },\n        {\n            pattern: /race|ethnic|nationality/,\n            confidence: 0.98,\n            risk: \"high\"\n        },\n        {\n            pattern: /religion|faith/,\n            confidence: 0.9,\n            risk: \"high\"\n        },\n        {\n            pattern: /disability|handicap/,\n            confidence: 0.88,\n            risk: \"high\"\n        },\n        {\n            pattern: /marital|marriage/,\n            confidence: 0.85,\n            risk: \"medium\"\n        },\n        {\n            pattern: /zip|postal|address/,\n            confidence: 0.75,\n            risk: \"medium\"\n        },\n        {\n            pattern: /income|salary|wage/,\n            confidence: 0.8,\n            risk: \"medium\"\n        },\n        {\n            pattern: /education|degree/,\n            confidence: 0.7,\n            risk: \"medium\"\n        }\n    ];\n    for (const { pattern, confidence, risk } of protectedPatterns){\n        if (pattern.test(name)) {\n            return {\n                isProtected: true,\n                confidence,\n                riskLevel: risk\n            };\n        }\n    }\n    // Check values for potential protected attribute indicators\n    const uniqueValues = [\n        ...new Set(values.slice(0, 100))\n    ].map((v)=>v === null || v === void 0 ? void 0 : v.toString().toLowerCase());\n    // Gender indicators\n    if (uniqueValues.some((v)=>[\n            \"male\",\n            \"female\",\n            \"m\",\n            \"f\",\n            \"man\",\n            \"woman\"\n        ].includes(v))) {\n        return {\n            isProtected: true,\n            confidence: 0.9,\n            riskLevel: \"high\"\n        };\n    }\n    // Age indicators (numeric ranges that look like ages)\n    const numericValues = values.filter((v)=>!isNaN(Number(v))).map(Number);\n    if (numericValues.length > 0) {\n        const min = Math.min(...numericValues);\n        const max = Math.max(...numericValues);\n        if (min >= 16 && max <= 100 && max - min > 10) {\n            return {\n                isProtected: true,\n                confidence: 0.85,\n                riskLevel: \"high\"\n            };\n        }\n    }\n    return {\n        isProtected: false,\n        confidence: 0.1,\n        riskLevel: \"low\"\n    };\n}\n// Function to determine column data type\nfunction detectColumnType(values) {\n    const nonEmptyValues = values.filter((v)=>v !== null && v !== undefined && v !== \"\");\n    if (nonEmptyValues.length === 0) return \"unknown\";\n    // Check if all values are numeric\n    const numericValues = nonEmptyValues.filter((v)=>!isNaN(Number(v)));\n    if (numericValues.length / nonEmptyValues.length > 0.8) {\n        return \"numerical\";\n    }\n    // Check if values look like dates\n    const dateValues = nonEmptyValues.filter((v)=>!isNaN(Date.parse(v)));\n    if (dateValues.length / nonEmptyValues.length > 0.8) {\n        return \"date\";\n    }\n    // Check if boolean-like\n    const booleanValues = nonEmptyValues.filter((v)=>[\n            \"true\",\n            \"false\",\n            \"yes\",\n            \"no\",\n            \"1\",\n            \"0\",\n            \"y\",\n            \"n\"\n        ].includes(v.toLowerCase()));\n    if (booleanValues.length / nonEmptyValues.length > 0.8) {\n        return \"boolean\";\n    }\n    return \"categorical\";\n}\n// Parse CSV content\nfunction parseCSV(csvContent) {\n    const lines = csvContent.split(\"\\n\").filter((line)=>line.trim());\n    if (lines.length === 0) throw new Error(\"Empty CSV file\");\n    // Parse headers\n    const headers = lines[0].split(\",\").map((h)=>h.trim().replace(/\"/g, \"\"));\n    // Parse rows\n    const rows = lines.slice(1).map((line)=>{\n        return line.split(\",\").map((cell)=>cell.trim().replace(/\"/g, \"\"));\n    });\n    return {\n        headers,\n        rows\n    };\n}\nasync function processDataset(file) {\n    return new Promise((resolve, reject)=>{\n        const reader = new FileReader();\n        reader.onload = (e)=>{\n            try {\n                var _e_target;\n                const content = (_e_target = e.target) === null || _e_target === void 0 ? void 0 : _e_target.result;\n                const startTime = Date.now();\n                // Parse the CSV\n                const { headers, rows } = parseCSV(content);\n                // Analyze each column\n                const identifiedAttributes = headers.map((header, index)=>{\n                    const columnValues = rows.map((row)=>row[index] || \"\").filter((v)=>v !== \"\");\n                    const uniqueValues = [\n                        ...new Set(columnValues)\n                    ].slice(0, 10);\n                    const type = detectColumnType(columnValues);\n                    const { isProtected, confidence, riskLevel } = analyzeColumnForProtectedAttributes(header, columnValues);\n                    let range = \"\";\n                    if (type === \"numerical\") {\n                        const numbers = columnValues.map(Number).filter((n)=>!isNaN(n));\n                        if (numbers.length > 0) {\n                            range = \"\".concat(Math.min(...numbers), \" - \").concat(Math.max(...numbers));\n                        }\n                    }\n                    return {\n                        name: header,\n                        type,\n                        uniqueValues: type === \"categorical\" ? uniqueValues : undefined,\n                        range: type === \"numerical\" ? range : undefined,\n                        confidence,\n                        examples: uniqueValues.slice(0, 3),\n                        isProtected,\n                        riskLevel,\n                        sampleCount: columnValues.length\n                    };\n                });\n                const processingTime = ((Date.now() - startTime) / 1000).toFixed(1);\n                // Create preview data (first 5 rows)\n                const preview = rows.slice(0, 5).map((row)=>{\n                    const obj = {};\n                    headers.forEach((header, index)=>{\n                        obj[header] = row[index] || \"\";\n                    });\n                    return obj;\n                });\n                resolve({\n                    success: true,\n                    message: \"Dataset processed successfully with real data analysis\",\n                    data: {\n                        rowCount: rows.length,\n                        columnCount: headers.length,\n                        columns: headers,\n                        identifiedAttributes,\n                        processingTime: \"\".concat(processingTime, \" seconds\"),\n                        aiConfidence: 0.94,\n                        preview\n                    }\n                });\n            } catch (error) {\n                reject(new Error(\"Failed to process CSV: \".concat(error)));\n            }\n        };\n        reader.onerror = ()=>{\n            reject(new Error(\"Failed to read file\"));\n        };\n        reader.readAsText(file);\n    });\n}\n// Store processed data globally (in a real app, you'd use proper state management)\nlet processedDatasetCache = null;\nfunction setProcessedDataset(data) {\n    processedDatasetCache = data;\n}\nfunction getProcessedDataset() {\n    return processedDatasetCache;\n}\n// Store fairness results from the backend\nlet fairnessResultCache = null;\nasync function uploadDatasetToBackend(file) {\n    const formData = new FormData();\n    formData.append(\"file\", file);\n    const res = await fetch(\"http://localhost:8000/fairness-check\", {\n        method: \"POST\",\n        body: formData\n    });\n    if (!res.ok) {\n        throw new Error(\"Failed to upload dataset to backend\");\n    }\n    const data = await res.json();\n    fairnessResultCache = data;\n    return data;\n}\nfunction getFairnessResult() {\n    return fairnessResultCache;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2xpYi9wcm9jZXNzLWRhdGFzZXQudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Q0FFQyxHQTRCRCxnRUFBZ0U7QUFDaEUsU0FBU0Esb0NBQ1BDLFVBQWtCLEVBQ2xCQyxNQUFnQjtJQU1oQixNQUFNQyxPQUFPRixXQUFXRyxXQUFXO0lBRW5DLHFDQUFxQztJQUNyQyxNQUFNQyxvQkFBb0I7UUFDeEI7WUFBRUMsU0FBUztZQUFjQyxZQUFZO1lBQU1DLE1BQU07UUFBTztRQUN4RDtZQUFFRixTQUFTO1lBQWlCQyxZQUFZO1lBQU1DLE1BQU07UUFBTztRQUMzRDtZQUFFRixTQUFTO1lBQTJCQyxZQUFZO1lBQU1DLE1BQU07UUFBTztRQUNyRTtZQUFFRixTQUFTO1lBQWtCQyxZQUFZO1lBQUtDLE1BQU07UUFBTztRQUMzRDtZQUFFRixTQUFTO1lBQXVCQyxZQUFZO1lBQU1DLE1BQU07UUFBTztRQUNqRTtZQUFFRixTQUFTO1lBQW9CQyxZQUFZO1lBQU1DLE1BQU07UUFBUztRQUNoRTtZQUFFRixTQUFTO1lBQXNCQyxZQUFZO1lBQU1DLE1BQU07UUFBUztRQUNsRTtZQUFFRixTQUFTO1lBQXNCQyxZQUFZO1lBQUtDLE1BQU07UUFBUztRQUNqRTtZQUFFRixTQUFTO1lBQW9CQyxZQUFZO1lBQUtDLE1BQU07UUFBUztLQUNoRTtJQUVELEtBQUssTUFBTSxFQUFFRixPQUFPLEVBQUVDLFVBQVUsRUFBRUMsSUFBSSxFQUFFLElBQUlILGtCQUFtQjtRQUM3RCxJQUFJQyxRQUFRRyxJQUFJLENBQUNOLE9BQU87WUFDdEIsT0FBTztnQkFBRU8sYUFBYTtnQkFBTUg7Z0JBQVlJLFdBQVdIO1lBQUs7UUFDMUQ7SUFDRjtJQUVBLDREQUE0RDtJQUM1RCxNQUFNSSxlQUFlO1dBQUksSUFBSUMsSUFBSVgsT0FBT1ksS0FBSyxDQUFDLEdBQUc7S0FBTSxDQUFDQyxHQUFHLENBQUMsQ0FBQ0MsSUFBTUEsY0FBQUEsd0JBQUFBLEVBQUdDLFFB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QUlDO0lBQ3JCRCxTQUFTRSxNQUFNLENBQUMsUUFBUTlDO0lBRXhCLE1BQU0rQyxNQUFNLE1BQU1DLE1BQU0sd0NBQXdDO1FBQzlEQyxRQUFRO1FBQ1JDLE1BQU1OO0lBQ1I7SUFFQSxJQUFJLENBQUNHLElBQUlJLEVBQUUsRUFBRTtRQUNYLE1BQU0sSUFBSTFELE1BQU07SUFDbEI7SUFFQSxNQUFNc0MsT0FBTyxNQUFNZ0IsSUFBSUssSUFBSTtJQUMzQlYsc0JBQXNCWDtJQUN0QixPQUFPQTtBQUNUO0FBRU8sU0FBU3NCO0lBQ2QsT0FBT1g7QUFDVCIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFx0ZWphc1xcT25lRHJpdmVcXOusuOyEnFxcZmFpcm5lc3MtYWdlbnRcXGFpLWdvdmVybmFuY2UtZGFzaGJvYXJkXFxmcm9udGVuZFxcbGliXFxwcm9jZXNzLWRhdGFzZXQudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBSZWFsIENTViBwcm9jZXNzaW5nIGltcGxlbWVudGF0aW9uXG4gKi9cblxuaW50ZXJmYWNlIFByb2Nlc3NlZENvbHVtbiB7XG4gIG5hbWU6IHN0cmluZ1xuICB0eXBlOiBzdHJpbmdcbiAgdW5pcXVlVmFsdWVzPzogc3RyaW5nW11cbiAgcmFuZ2U/OiBzdHJpbmdcbiAgY29uZmlkZW5jZTogbnVtYmVyXG4gIGV4YW1wbGVzOiBzdHJpbmdbXVxuICBpc1Byb3RlY3RlZDogYm9vbGVhblxuICByaXNrTGV2ZWw6IHN0cmluZ1xuICBzYW1wbGVDb3VudDogbnVtYmVyXG59XG5cbmludGVyZmFjZSBQcm9jZXNzZWREYXRhc2V0IHtcbiAgc3VjY2VzczogYm9vbGVhblxuICBtZXNzYWdlOiBzdHJpbmdcbiAgZGF0YToge1xuICAgIHJvd0NvdW50OiBudW1iZXJcbiAgICBjb2x1bW5Db3VudDogbnVtYmVyXG4gICAgY29sdW1uczogc3RyaW5nW11cbiAgICBpZGVudGlmaWVkQXR0cmlidXRlczogUHJvY2Vzc2VkQ29sdW1uW11cbiAgICBwcm9jZXNzaW5nVGltZTogc3RyaW5nXG4gICAgYWlDb25maWRlbmNlOiBudW1iZXJcbiAgICBwcmV2aWV3OiBhbnlbXVxuICB9XG59XG5cbi8vIEZ1bmN0aW9uIHRvIGRldGVjdCBpZiBhIGNvbHVtbiBtaWdodCBiZSBhIHByb3RlY3RlZCBhdHRyaWJ1dGVcbmZ1bmN0aW9uIGFuYWx5emVDb2x1bW5Gb3JQcm90ZWN0ZWRBdHRyaWJ1dGVzKFxuICBjb2x1bW5OYW1lOiBzdHJpbmcsXG4gIHZhbHVlczogc3RyaW5nW10sXG4pOiB7XG4gIGlzUHJvdGVjdGVkOiBib29sZWFuXG4gIGNvbmZpZGVuY2U6IG51bWJlclxuICByaXNrTGV2ZWw6IHN0cmluZ1xufSB7XG4gIGNvbnN0IG5hbWUgPSBjb2x1bW5OYW1lLnRvTG93ZXJDYXNlKClcblxuICAvLyBLbm93biBwcm90ZWN0ZWQgYXR0cmlidXRlIHBhdHRlcm5zXG4gIGNvbnN0IHByb3RlY3RlZFBhdHRlcm5zID0gW1xuICAgIHsgcGF0dGVybjogL2dlbmRlcnxzZXgvLCBjb25maWRlbmNlOiAwLjk1LCByaXNrOiBcImhpZ2hcIiB9LFxuICAgIHsgcGF0dGVybjogL2FnZXxiaXJ0aHxkb2IvLCBjb25maWRlbmNlOiAwLjkyLCByaXNrOiBcImhpZ2hcIiB9LFxuICAgIHsgcGF0dGVybjogL3JhY2V8ZXRobmljfG5hdGlvbmFsaXR5LywgY29uZmlkZW5jZTogMC45OCwgcmlzazogXCJoaWdoXCIgfSxcbiAgICB7IHBhdHRlcm46IC9yZWxpZ2lvbnxmYWl0aC8sIGNvbmZpZGVuY2U6IDAuOSwgcmlzazogXCJoaWdoXCIgfSxcbiAgICB7IHBhdHRlcm46IC9kaXNhYmlsaXR5fGhhbmRpY2FwLywgY29uZmlkZW5jZTogMC44OCwgcmlzazogXCJoaWdoXCIgfSxcbiAgICB7IHBhdHRlcm46IC9tYXJpdGFsfG1hcnJpYWdlLywgY29uZmlkZW5jZTogMC44NSwgcmlzazogXCJtZWRpdW1cIiB9LFxuICAgIHsgcGF0dGVybjogL3ppcHxwb3N0YWx8YWRkcmVzcy8sIGNvbmZpZGVuY2U6IDAuNzUsIHJpc2s6IFwibWVkaXVtXCIgfSxcbiAgICB7IHBhdHRlcm46IC9pbmNvbWV8c2FsYXJ5fHdhZ2UvLCBjb25maWRlbmNlOiAwLjgsIHJpc2s6IFwibWVkaXVtXCIgfSxcbiAgICB7IHBhdHRlcm46IC9lZHVjYXRpb258ZGVncmVlLywgY29uZmlkZW5jZTogMC43LCByaXNrOiBcIm1lZGl1bVwiIH0sXG4gIF1cblxuICBmb3IgKGNvbnN0IHsgcGF0dGVybiwgY29uZmlkZW5jZSwgcmlzayB9IG9mIHByb3RlY3RlZFBhdHRlcm5zKSB7XG4gICAgaWYgKHBhdHRlcm4udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHsgaXNQcm90ZWN0ZWQ6IHRydWUsIGNvbmZpZGVuY2UsIHJpc2tMZXZlbDogcmlzayB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hlY2sgdmFsdWVzIGZvciBwb3RlbnRpYWwgcHJvdGVjdGVkIGF0dHJpYnV0ZSBpbmRpY2F0b3JzXG4gIGNvbnN0IHVuaXF1ZVZhbHVlcyA9IFsuLi5uZXcgU2V0KHZhbHVlcy5zbGljZSgwLCAxMDApKV0ubWFwKCh2KSA9PiB2Py50b1N0cmluZygpLnRvTG93ZXJDYXNlKCkpXG5cbiAgLy8gR2VuZGVyIGluZGljYXRvcnNcbiAgaWYgKHVuaXF1ZVZhbHVlcy5zb21lKCh2KSA9PiBbXCJtYWxlXCIsIFwiZmVtYWxlXCIsIFwibVwiLCBcImZcIiwgXCJtYW5cIiwgXCJ3b21hblwiXS5pbmNsdWRlcyh2KSkpIHtcbiAgICByZXR1cm4geyBpc1Byb3RlY3RlZDogdHJ1ZSwgY29uZmlkZW5jZTogMC45LCByaXNrTGV2ZWw6IFwiaGlnaFwiIH1cbiAgfVxuXG4gIC8vIEFnZSBpbmRpY2F0b3JzIChudW1lcmljIHJhbmdlcyB0aGF0IGxvb2sgbGlrZSBhZ2VzKVxuICBjb25zdCBudW1lcmljVmFsdWVzID0gdmFsdWVzLmZpbHRlcigodikgPT4gIWlzTmFOKE51bWJlcih2KSkpLm1hcChOdW1iZXIpXG4gIGlmIChudW1lcmljVmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBtaW4gPSBNYXRoLm1pbiguLi5udW1lcmljVmFsdWVzKVxuICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KC4uLm51bWVyaWNWYWx1ZXMpXG4gICAgaWYgKG1pbiA+PSAxNiAmJiBtYXggPD0gMTAwICYmIG1heCAtIG1pbiA+IDEwKSB7XG4gICAgICByZXR1cm4geyBpc1Byb3RlY3RlZDogdHJ1ZSwgY29uZmlkZW5jZTogMC44NSwgcmlza0xldmVsOiBcImhpZ2hcIiB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHsgaXNQcm90ZWN0ZWQ6IGZhbHNlLCBjb25maWRlbmNlOiAwLjEsIHJpc2tMZXZlbDogXCJsb3dcIiB9XG59XG5cbi8vIEZ1bmN0aW9uIHRvIGRldGVybWluZSBjb2x1bW4gZGF0YSB0eXBlXG5mdW5jdGlvbiBkZXRlY3RDb2x1bW5UeXBlKHZhbHVlczogc3RyaW5nW10pOiBzdHJpbmcge1xuICBjb25zdCBub25FbXB0eVZhbHVlcyA9IHZhbHVlcy5maWx0ZXIoKHYpID0+IHYgIT09IG51bGwgJiYgdiAhPT0gdW5kZWZpbmVkICYmIHYgIT09IFwiXCIpXG5cbiAgaWYgKG5vbkVtcHR5VmFsdWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFwidW5rbm93blwiXG5cbiAgLy8gQ2hlY2sgaWYgYWxsIHZhbHVlcyBhcmUgbnVtZXJpY1xuICBjb25zdCBudW1lcmljVmFsdWVzID0gbm9uRW1wdHlWYWx1ZXMuZmlsdGVyKCh2KSA9PiAhaXNOYU4oTnVtYmVyKHYpKSlcbiAgaWYgKG51bWVyaWNWYWx1ZXMubGVuZ3RoIC8gbm9uRW1wdHlWYWx1ZXMubGVuZ3RoID4gMC44KSB7XG4gICAgcmV0dXJuIFwibnVtZXJpY2FsXCJcbiAgfVxuXG4gIC8vIENoZWNrIGlmIHZhbHVlcyBsb29rIGxpa2UgZGF0ZXNcbiAgY29uc3QgZGF0ZVZhbHVlcyA9IG5vbkVtcHR5VmFsdWVzLmZpbHRlcigodikgPT4gIWlzTmFOKERhdGUucGFyc2UodikpKVxuICBpZiAoZGF0ZVZhbHVlcy5sZW5ndGggLyBub25FbXB0eVZhbHVlcy5sZW5ndGggPiAwLjgpIHtcbiAgICByZXR1cm4gXCJkYXRlXCJcbiAgfVxuXG4gIC8vIENoZWNrIGlmIGJvb2xlYW4tbGlrZVxuICBjb25zdCBib29sZWFuVmFsdWVzID0gbm9uRW1wdHlWYWx1ZXMuZmlsdGVyKCh2KSA9PlxuICAgIFtcInRydWVcIiwgXCJmYWxzZVwiLCBcInllc1wiLCBcIm5vXCIsIFwiMVwiLCBcIjBcIiwgXCJ5XCIsIFwiblwiXS5pbmNsdWRlcyh2LnRvTG93ZXJDYXNlKCkpLFxuICApXG4gIGlmIChib29sZWFuVmFsdWVzLmxlbmd0aCAvIG5vbkVtcHR5VmFsdWVzLmxlbmd0aCA+IDAuOCkge1xuICAgIHJldHVybiBcImJvb2xlYW5cIlxuICB9XG5cbiAgcmV0dXJuIFwiY2F0ZWdvcmljYWxcIlxufVxuXG4vLyBQYXJzZSBDU1YgY29udGVudFxuZnVuY3Rpb24gcGFyc2VDU1YoY3N2Q29udGVudDogc3RyaW5nKTogeyBoZWFkZXJzOiBzdHJpbmdbXTsgcm93czogc3RyaW5nW11bXSB9IHtcbiAgY29uc3QgbGluZXMgPSBjc3ZDb250ZW50LnNwbGl0KFwiXFxuXCIpLmZpbHRlcigobGluZSkgPT4gbGluZS50cmltKCkpXG4gIGlmIChsaW5lcy5sZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcihcIkVtcHR5IENTViBmaWxlXCIpXG5cbiAgLy8gUGFyc2UgaGVhZGVyc1xuICBjb25zdCBoZWFkZXJzID0gbGluZXNbMF0uc3BsaXQoXCIsXCIpLm1hcCgoaCkgPT4gaC50cmltKCkucmVwbGFjZSgvXCIvZywgXCJcIikpXG5cbiAgLy8gUGFyc2Ugcm93c1xuICBjb25zdCByb3dzID0gbGluZXMuc2xpY2UoMSkubWFwKChsaW5lKSA9PiB7XG4gICAgcmV0dXJuIGxpbmUuc3BsaXQoXCIsXCIpLm1hcCgoY2VsbCkgPT4gY2VsbC50cmltKCkucmVwbGFjZSgvXCIvZywgXCJcIikpXG4gIH0pXG5cbiAgcmV0dXJuIHsgaGVhZGVycywgcm93cyB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwcm9jZXNzRGF0YXNldChmaWxlOiBGaWxlKTogUHJvbWlzZTxQcm9jZXNzZWREYXRhc2V0PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuXG4gICAgcmVhZGVyLm9ubG9hZCA9IChlKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gZS50YXJnZXQ/LnJlc3VsdCBhcyBzdHJpbmdcbiAgICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKVxuXG4gICAgICAgIC8vIFBhcnNlIHRoZSBDU1ZcbiAgICAgICAgY29uc3QgeyBoZWFkZXJzLCByb3dzIH0gPSBwYXJzZUNTVihjb250ZW50KVxuXG4gICAgICAgIC8vIEFuYWx5emUgZWFjaCBjb2x1bW5cbiAgICAgICAgY29uc3QgaWRlbnRpZmllZEF0dHJpYnV0ZXM6IFByb2Nlc3NlZENvbHVtbltdID0gaGVhZGVycy5tYXAoKGhlYWRlciwgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCBjb2x1bW5WYWx1ZXMgPSByb3dzLm1hcCgocm93KSA9PiByb3dbaW5kZXhdIHx8IFwiXCIpLmZpbHRlcigodikgPT4gdiAhPT0gXCJcIilcbiAgICAgICAgICBjb25zdCB1bmlxdWVWYWx1ZXMgPSBbLi4ubmV3IFNldChjb2x1bW5WYWx1ZXMpXS5zbGljZSgwLCAxMClcblxuICAgICAgICAgIGNvbnN0IHR5cGUgPSBkZXRlY3RDb2x1bW5UeXBlKGNvbHVtblZhbHVlcylcbiAgICAgICAgICBjb25zdCB7IGlzUHJvdGVjdGVkLCBjb25maWRlbmNlLCByaXNrTGV2ZWwgfSA9IGFuYWx5emVDb2x1bW5Gb3JQcm90ZWN0ZWRBdHRyaWJ1dGVzKGhlYWRlciwgY29sdW1uVmFsdWVzKVxuXG4gICAgICAgICAgbGV0IHJhbmdlID0gXCJcIlxuICAgICAgICAgIGlmICh0eXBlID09PSBcIm51bWVyaWNhbFwiKSB7XG4gICAgICAgICAgICBjb25zdCBudW1iZXJzID0gY29sdW1uVmFsdWVzLm1hcChOdW1iZXIpLmZpbHRlcigobikgPT4gIWlzTmFOKG4pKVxuICAgICAgICAgICAgaWYgKG51bWJlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICByYW5nZSA9IGAke01hdGgubWluKC4uLm51bWJlcnMpfSAtICR7TWF0aC5tYXgoLi4ubnVtYmVycyl9YFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBoZWFkZXIsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgdW5pcXVlVmFsdWVzOiB0eXBlID09PSBcImNhdGVnb3JpY2FsXCIgPyB1bmlxdWVWYWx1ZXMgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICByYW5nZTogdHlwZSA9PT0gXCJudW1lcmljYWxcIiA/IHJhbmdlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY29uZmlkZW5jZSxcbiAgICAgICAgICAgIGV4YW1wbGVzOiB1bmlxdWVWYWx1ZXMuc2xpY2UoMCwgMyksXG4gICAgICAgICAgICBpc1Byb3RlY3RlZCxcbiAgICAgICAgICAgIHJpc2tMZXZlbCxcbiAgICAgICAgICAgIHNhbXBsZUNvdW50OiBjb2x1bW5WYWx1ZXMubGVuZ3RoLFxuICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBjb25zdCBwcm9jZXNzaW5nVGltZSA9ICgoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSkgLyAxMDAwKS50b0ZpeGVkKDEpXG5cbiAgICAgICAgLy8gQ3JlYXRlIHByZXZpZXcgZGF0YSAoZmlyc3QgNSByb3dzKVxuICAgICAgICBjb25zdCBwcmV2aWV3ID0gcm93cy5zbGljZSgwLCA1KS5tYXAoKHJvdykgPT4ge1xuICAgICAgICAgIGNvbnN0IG9iajogYW55ID0ge31cbiAgICAgICAgICBoZWFkZXJzLmZvckVhY2goKGhlYWRlciwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIG9ialtoZWFkZXJdID0gcm93W2luZGV4XSB8fCBcIlwiXG4gICAgICAgICAgfSlcbiAgICAgICAgICByZXR1cm4gb2JqXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICBtZXNzYWdlOiBcIkRhdGFzZXQgcHJvY2Vzc2VkIHN1Y2Nlc3NmdWxseSB3aXRoIHJlYWwgZGF0YSBhbmFseXNpc1wiLFxuICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgIHJvd0NvdW50OiByb3dzLmxlbmd0aCxcbiAgICAgICAgICAgIGNvbHVtbkNvdW50OiBoZWFkZXJzLmxlbmd0aCxcbiAgICAgICAgICAgIGNvbHVtbnM6IGhlYWRlcnMsXG4gICAgICAgICAgICBpZGVudGlmaWVkQXR0cmlidXRlcyxcbiAgICAgICAgICAgIHByb2Nlc3NpbmdUaW1lOiBgJHtwcm9jZXNzaW5nVGltZX0gc2Vjb25kc2AsXG4gICAgICAgICAgICBhaUNvbmZpZGVuY2U6IDAuOTQsXG4gICAgICAgICAgICBwcmV2aWV3LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QobmV3IEVycm9yKGBGYWlsZWQgdG8gcHJvY2VzcyBDU1Y6ICR7ZXJyb3J9YCkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVhZGVyLm9uZXJyb3IgPSAoKSA9PiB7XG4gICAgICByZWplY3QobmV3IEVycm9yKFwiRmFpbGVkIHRvIHJlYWQgZmlsZVwiKSlcbiAgICB9XG5cbiAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKVxuICB9KVxufVxuXG4vLyBTdG9yZSBwcm9jZXNzZWQgZGF0YSBnbG9iYWxseSAoaW4gYSByZWFsIGFwcCwgeW91J2QgdXNlIHByb3BlciBzdGF0ZSBtYW5hZ2VtZW50KVxubGV0IHByb2Nlc3NlZERhdGFzZXRDYWNoZTogUHJvY2Vzc2VkRGF0YXNldCB8IG51bGwgPSBudWxsXG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRQcm9jZXNzZWREYXRhc2V0KGRhdGE6IFByb2Nlc3NlZERhdGFzZXQpIHtcbiAgcHJvY2Vzc2VkRGF0YXNldENhY2hlID0gZGF0YVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvY2Vzc2VkRGF0YXNldCgpOiBQcm9jZXNzZWREYXRhc2V0IHwgbnVsbCB7XG4gIHJldHVybiBwcm9jZXNzZWREYXRhc2V0Q2FjaGVcbn1cbi8vIFN0b3JlIGZhaXJuZXNzIHJlc3VsdHMgZnJvbSB0aGUgYmFja2VuZFxubGV0IGZhaXJuZXNzUmVzdWx0Q2FjaGU6IGFueSA9IG51bGxcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwbG9hZERhdGFzZXRUb0JhY2tlbmQoZmlsZTogRmlsZSkge1xuICBjb25zdCBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpXG4gIGZvcm1EYXRhLmFwcGVuZChcImZpbGVcIiwgZmlsZSlcblxuICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChcImh0dHA6Ly9sb2NhbGhvc3Q6ODAwMC9mYWlybmVzcy1jaGVja1wiLCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBib2R5OiBmb3JtRGF0YSxcbiAgfSlcblxuICBpZiAoIXJlcy5vaykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byB1cGxvYWQgZGF0YXNldCB0byBiYWNrZW5kXCIpXG4gIH1cblxuICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKVxuICBmYWlybmVzc1Jlc3VsdENhY2hlID0gZGF0YVxuICByZXR1cm4gZGF0YVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmFpcm5lc3NSZXN1bHQoKSB7XG4gIHJldHVybiBmYWlybmVzc1Jlc3VsdENhY2hlXG59Il0sIm5hbWVzIjpbImFuYWx5emVDb2x1bW5Gb3JQcm90ZWN0ZWRBdHRyaWJ1dGVzIiwiY29sdW1uTmFtZSIsInZhbHVlcyIsIm5hbWUiLCJ0b0xvd2VyQ2FzZSIsInByb3RlY3RlZFBhdHRlcm5zIiwicGF0dGVybiIsImNvbmZpZGVuY2UiLCJyaXNrIiwidGVzdCIsImlzUHJvdGVjdGVkIiwicmlza0xldmVsIiwidW5pcXVlVmFsdWVzIiwiU2V0Iiwic2xpY2UiLCJtYXAiLCJ2IiwidG9TdHJpbmciLCJzb21lIiwiaW5jbHVkZXMiLCJudW1lcmljVmFsdWVzIiwiZmlsdGVyIiwiaXNOYU4iLCJOdW1iZXIiLCJsZW5ndGgiLCJtaW4iLCJNYXRoIiwibWF4IiwiZGV0ZWN0Q29sdW1uVHlwZSIsIm5vbkVtcHR5VmFsdWVzIiwidW5kZWZpbmVkIiwiZGF0ZVZhbHVlcyIsIkRhdGUiLCJwYXJzZSIsImJvb2xlYW5WYWx1ZXMiLCJwYXJzZUNTViIsImNzdkNvbnRlbnQiLCJsaW5lcyIsInNwbGl0IiwibGluZSIsInRyaW0iLCJFcnJvciIsImhlYWRlcnMiLCJoIiwicmVwbGFjZSIsInJvd3MiLCJjZWxsIiwicHJvY2Vzc0RhdGFzZXQiLCJmaWxlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJyZWFkZXIiLCJGaWxlUmVhZGVyIiwib25sb2FkIiwiZSIsImNvbnRlbnQiLCJ0YXJnZXQiLCJyZXN1bHQiLCJzdGFydFRpbWUiLCJub3ciLCJpZGVudGlmaWVkQXR0cmlidXRlcyIsImhlYWRlciIsImluZGV4IiwiY29sdW1uVmFsdWVzIiwicm93IiwidHlwZSIsInJhbmdlIiwibnVtYmVycyIsIm4iLCJleGFtcGxlcyIsInNhbXBsZUNvdW50IiwicHJvY2Vzc2luZ1RpbWUiLCJ0b0ZpeGVkIiwicHJldmlldyIsIm9iaiIsImZvckVhY2giLCJzdWNjZXNzIiwibWVzc2FnZSIsImRhdGEiLCJyb3dDb3VudCIsImNvbHVtbkNvdW50IiwiY29sdW1ucyIsImFpQ29uZmlkZW5jZSIsImVycm9yIiwib25lcnJvciIsInJlYWRBc1RleHQiLCJwcm9jZXNzZWREYXRhc2V0Q2FjaGUiLCJzZXRQcm9jZXNzZWREYXRhc2V0IiwiZ2V0UHJvY2Vzc2VkRGF0YXNldCIsImZhaXJuZXNzUmVzdWx0Q2FjaGUiLCJ1cGxvYWREYXRhc2V0VG9CYWNrZW5kIiwiZm9ybURhdGEiLCJGb3JtRGF0YSIsImFwcGVuZCIsInJlcyIsImZldGNoIiwibWV0aG9kIiwiYm9keSIsIm9rIiwianNvbiIsImdldEZhaXJuZXNzUmVzdWx0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/process-dataset.ts\n"));

/***/ })

});